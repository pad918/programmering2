\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{minted}

\title{Derivata lab1 ID1019}
\author{Måns Abrahamsson}
\date{2023-01-22}

\begin{document}

\maketitle

\section{Introduktion}
I den här laborationen ska ett program implementeras i elixir som från en funktion hittar dess derivata med respekt till en variabel. ...

\section{Representation av funktioner}

I elixir repressenteras funktionerna som tupler som beskriver en matematisk operation och dess argument. Det första elementet i tuplerna är en atom som beskriver operationens typ och resterande elementen är uttrycken som operationen utförs på. För att lösa uppgiften skapades följande operationer

\begin{table}[h!]
\begin{center}
\begin{tabular}{c|c|c}
\textbf{Operation} & \textbf{atom} & \textbf{tupeln storlek}\\
\hline
Addition & :add & 3\\
Multiplikation & :mul & 3\\
Divition & :div & 3\\
Potens & :pow & 3\\
Sinus & :sin & 2\\
Cosinus & :cos & 2\\
Naturliga logaritmen & :ln & 2\\
Konstant nummer & :num & 2\\
Variabel & :var & 2\\
Kvadratroten & :sqrt & 2 \\
\end{tabular}
\caption{}
\label{tab:table1}
\end{center}
\end{table}

\subsection{Utskrivning av funktioner}
För att göra det enklare att läsa funktioner med denna representation skapades en funktion print/1 som för om funktionen till en mer läsbar version genom att göra om tuplerna från forman {operation, a1, a2} till (a1 operation a2) och för 2-tuplerna {operation, a1} till operation(a1) förutom variabler och konstanter som skrevs ut som de är.

\section{Beräkna derivatan}
Att beräkna derivatan av en funktion med den representationen som används är i sig inte ett särskillt svårt problem eftersom varje derivieringsregel enkelt kan implementeras som en funktion i elixir. Detta är dock inte en fullständig lösning eftersom deriveringsreglerna anger vad derivatan av en funktion f(x) är, men i detta fall kan x vara en funktion i sig. F(x) blir därmed en kompositfunktion i formen f(g(x)) och för att beräkna kompositfunktionens derivata används kedjeregeln. 

\subsection{kedjeregeln}
Eftersom flera av reglerna, bland annat sin, ln och pow måste ta hänsyn till kedjeregeln för att hitta derivatan till g(x) skapades en hjälpfunktion $chain(f\_deriv, g, x)$ där g är inrefunktion till f och f\_deriv är derivatan av f med respekt till g. X är variabeln som deriveras med. Funktionen använder sig av kedjeregeln för att returnera derivatan av f(g(x)) med respekt till x.

\subsection{Implementerade deriveringsregler}
Uppgiften krävde att derivatan av följande funktioner skulle implementeras:

\subsubsection{Konstanter och variabler}
Derivatan av en konstant returnerar alltid 0 och derivatan av en konstant returnerar 1 ifall det är samma variabel som vi deriverar med, annars returnerar den noll.

\subsubsection{Addition och multiplikation}
Derivatan av summan av två funktioner f och g är samma som summan av derivatorna till funktionerna. Detta implementerades genom att kalla deriv funktionern för respektive funktion och summera resultaten. 
\newline
Multiplikation fungerar på liknande sätt fast derivatorna mulipliseras först med den andra funktionen innan de summeras: $(f*g)' = f'*g+g'*f$. I båda dessa behöver inte kedjeregelsfunktionen användas.

\subsubsection{Potensfunktion}
Derivatan av en potensfunktion i formen $x^n$ beräknas som $n*x^{n-1}$. I detta fallet måste dock kedjeregeln tas hänsyn till. Detta görs genom att använda hjälpmetoden för kedjeregeln som skapades.

\subsubsection{Inversen}
Uppgiften krävde att derivatan av $\frac{1}{x}$ skulle kunna hittas. För att göra regeln lite mer generell implementerades istället deriveringsregeln för $\frac{f}{g}$ som definieras som $\frac{f'*g-g'*f}{g^2}$. Eftersom den redan är definierad för två funktioner behövdes inte kedjeregeln användas.

\subsubsection{Logaritmer, sinus och kvadratroten}
Derivatan av den naturliga logaritmen och sinus implementerades enkelt genom att använda reglerna tillsammans med hjälpmetoden för kedjeregeln. Regeln för kvadratroten använder sig utav potenfunktionens implementerade deriveringsfunktion genom att först forma om uttrycket från $\sqrt{(g(x))}$ till $g(x)^{\frac{1}{2}}$ innan derivering utförs.

\section{Förenkling av uttryck}
Resultaten av deriveringen är oftast mycket komplicerade och långt från förenklade. Exempelvis förekommer det ofta x*0, x+0 eller 5+5. En funktion \textit{simplify/1} implementerades för att förenkla funktionsuttrycken. Förenklingsmetoden måste utföras längst innifrån och sedan utåt för att uppnå perfekt resultat. Detta uppnåddes genom att dela upp problemet i två delar. Den första tar uttryck i formen {type, a1} eller {type, a1, a2} där a1 och a2 först förenklas och därefter förenklas operationen i en annan funktion beroende på typen av operation. Exempelvis förenklas en addition som {:add, a1, a2} genom att kalla simplify\_add(simplify(a1), simplify(2)). Detta hanteras med en case sats ett utfall för varje typ av operation.

\subsection{Förenkling av adition}
\subsection{Förenkling av multiplikation}
\subsection{Förenkling av potenser}

\subsection{Diskussion}
Det finns ingen uppenbar enkel algoritm för att alltid uppnå en perfekt förenkling av ett uttryck. Med de förenklingar som implementerats blir det oftast bra för mindre funktioner, men för mycket stora funktioner finns det alltid flera förenklingar till som skulle kunna göras.

\end{document}
